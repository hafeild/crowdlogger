<html>
<head>
    <script src="js/external/jquery.min.js"></script>
    <script src="js/content-page.js"></script>
</head>
<body>
<div class="toc">
    <h2>Contents</h2>
    <ul>
        <!-- <li><a href="#implement">Implementing a CrowdLogger Remote Module</a> -->
        <li><a href="#implement:what-clrm-consists-of"
            >What a CLRM Package Consists of</a>
        <li><a href="#implement:core-module-structure"
            >The Structure of the Core Module Code</a>
        <li><a href="#implement:referencing-resources"
            >Referencing Module Resources</a>
        <li><a href="#implement:auto-packaging">Automatic Packaging</a> 
    </ul>
</div>

<h1>Implementing a CrowdLogger Remote Module</h1>

<p>
This page will contain information about implementing a module, including the
directory structure and some simple examples. It will also contain an overview
of the API. 
</p>

<p>
<span class="highlight"><b>Note:</b> While many of the sections below
go into the details of the underlying CLRM format, there is an automatic
method for generating the CLRM JSON description, which is discussed in the
<a href="#implement:auto-packaging">Automatic Packaging</a> section.
</span>
</p>

<a name="what-clrm-consists-of"></a>
<h2>What a CLRM Package Consists of</h2>
<p>
A CLRM Package is a JSON object with the following fields:
</p>

<table>
    <tr>
        <th>Field</th> <th width="125px">Type</th> <th>Description</th> 
    </tr><tr>
        <td><code>module</code></td>
        <td>string</td>
        <td>The core module code. 
            <a href="#implement:core-module-structure">This must adhere to the 
            structure described below</a>. This code will be evaluated using
            <code>eval()</code> and will have access to the package object
            (so resources can be accessed) as well as the CLRM API.
        </td>
    </tr><tr>
        <td><code>html</code></td>
        <td>map to strings</td>
        <td>A map of HTML document names to the document content. Each of these
            virtual files can be loaded into a window when needed. They can
            reference other sources from this object, including JavaScript 
            (see <code>js</code>), CSS (see <code>css</code>), and other HTML
            content. See the <a href="#implement:referencing-resources">
            Referencing Module Resources</a> section for more information about
            how to link to these resources.
        </td>
    </tr><tr>
        <td><code>js</code></td>
        <td>map to strings</td>
        <td>A map of JavaScript document names to the script content. The
            content will be inserted within <code>&lt;script&gt;</code> tags
            in the header of HTML documents that reference it.
        </td>
    </tr><tr>
        <td><code>css</code></td>
        <td>map to strings</td>
        <td>A map of CSS document names to the style sheet content. The
            content will be inserted within <code>&lt;style&gt;</code> tags
            in the header of HTML documents that reference it.
        </td>
    </tr><tr>
        <td><code>misc</code></td>
        <td>map to strings</td>
        <td>A map of miscellaneous resources names to content. When used in
            conjunction with a resource reference, the
            content will replace <code>::CLRMMISC:name</code> occurrences in,
            e.g., HTML documents.
        </td>
    </tr>
</table>



<!-- <pre class="prettyprint">
{
    string:
}
</pre> -->

<a name="core-module-structure"></a>
<h2>The Structure of the Core Module Code</h2>

<p>
The core module is the JavaScript stored under the <code>module</code> key in 
the CRLM Package. At a minimum, core modules must:
</p>

<ul>
    <li>contain a global function named <code>RemoteModule</code> that takes
        two parameters: the containing CLRM Package and a copy of the CLRM API.
        <span class="highlight">Note: this should be the only thing you add to
            the global space!</span>
    <li>make available an <code>id</code> field within the 
        <code>RemoteModule</code> instance
    <li>make available an <code>init</code> function within the 
        <code>RemoteModule</code> instance; <span class="highlight">Nothing 
        should be initialized outside of the <code>init</code> function! (<a
            href="#implement:note-on-init">see this note</a>)</span>
    <li>make available an <code>unload</code> function within the
        <code>RemoteModule</code> instance that takes a callback 
        function&mdash;this should be called when unloading is complete
</ul>

<p>
The <code>RemoteModule</code> function will be invoked with the <code>new</code>
keyword and passed a copy of the containing CLRM Package and a copy of the 
CLRM API. E.g.,
</p>

<pre class="prettyprint">
function RemoteModule( clrmPackage, api ){
    this.id = 'My Module';
    this.unload = function(oncomplete){ 
        oncomplete(); 
    };
    this.init = function(){
        api.ui.alert('Hi!');
    };
}    
</pre>

<p>
For larger modules, you will likely want to split your code up across files  (of
course, these will have to be concatenated before being added to the CLRM
Package). For instances, you may want to define a <code>Model</code> class that
provides functionality to maintain a persistent model over user interactions. To
avoid adding this to the global name space, but still allow your
<code>RemoteModule</code> class access to it, you can modify
<code>RemoteModule.prototype</code>. For example:
</p>

<pre class="prettyprint">
// file1.js

var RemoteModule = function( clrmPackge, api ){
    this.id = "My Module";
    // <a href="http://stackoverflow.com/questions/4886632/what-does-var-that-this-mean-in-javascript">See this page for more info about var that = this.</a>
    var that = this;
    var model;
    
    this.unload = function(oncomplete){
        // This save may happen asyncronously -- that is, when model.save
        // returns, the process of saving may still be occurring. So, we pass
        // oncomplete along so that whatever code uses it last can invoke it.
        model.save(oncomplete);
    };

    this.init = function(){
        model = new that.Model(api);
    };
}
</pre>

<pre class="prettyprint">
// file2.js

RemoteModule.prototype.Model = function(api){
    ...
    this.save = function(oncomplete){
        ...
        // Somewhere oncomplete() is invoked.
        ...
    };<!--
    // Private variables.
    var that = this,
        DB_NAME = "mydb",
        DB_VERSION = 1;

    // Private function declarations.
    var init, processSE, processQuery;

    // Public variables.
    this.data = {
        seCounts: {
            TOTAL: 0
        },
        queryTermCounts: {
            TOTAL: 0
        }
    };

    // Public function declarations.
    this.save;

    // Private function definitions.
    // Initialize the listeners.
    init = function(){
        // Add listeners to some user activity...
        api.user.realtime.onSearch(function(search){
            processSE(search.se);
            processQuery(search.query);
        });
    }

    // Increments a search engines occurence.
    processSE = function(se){
        var curCount = that.data.seCounts[se] ? 
            that.data.seCounts[se] : 0;
        that.data.seCounts[se] = curCount + 1;
        that.data.seCounts.TOTAL += 1;
    }

    // Updates the counts for each term that occurs in the query.
    processQuery = function(query){
        var terms = query.toLower().split(/\s+/), term;
        for( term in terms ){
            var curCount = that.data.queryTermCounts[term] ? 
                that.data.queryTermCounts[term] : 0;
            that.data.queryTermCounts[term] = curCount + 1;
            that.data.queryTermCounts.TOTAL += 1;
        }
    }

    // Public function definitions.
    // Save the data.
    this.save = function(){
        api.user.db.write(DB_NAME, DB_VERSION, that.data);
    };

    // Called on initialization.
    init();
-->
}
</pre>

<a name="note-on-init"></a>
<h3>A note on <code>init</code></h3>
<p>
The reason we require that nothing occur outside of the <code>init</code>
function in the core <code>RemoteModule</code> object is that, if an older 
version of your CLRM is loaded, we need to invoke the <code>unload</code>
function of that older instance. This might involve removing listeners
and such from elements, saving data, etc. Your new code will likely want to
reattach those listeners, read in the saved data, etc., so it must wait until
the clean up is complete.
</p>



<a name="referencing-resources"></a>
<h2>Referencing Module Resources</h2>

<p>
Assuming the CLRM Package is stored in the variable <code>package</code>,
references are made in HTML content in the following way:
</p>

<table>
    <tr>
        <th>Pattern</th> <th>Description</th> 
    </tr><tr> 
        <td><code>::CLRMJS:name</code></td>
        <td>Gets replaced with 
            <code> &lt;script&gt;package.js[name]&lt;script&gt; </code>
        </td>
    </tr><tr>
        <td><code>::CLRMCSS:name</code></td>
        <td>Gets replaced with 
            <code> &lt;style&gt;package.css[name]&lt;style&gt; </code>
        </td>
    </tr><tr>
        <td><code>::CLRMMISC:name</code></td>
        <td>Gets replaced with 
            <code> package.misc[name] </code>
        </td>
    </tr>

</table>


<a name="auto-packaging"></a>
<h2>Automatic Packaging</h2> 

<p>
It's tedious and error prone to have to package a CLRM manually. Rather than
do that, you can feed the core CLRM script and a set of resources&mdash;HTML,
JavaScript, and CSS files&mdash;to the <code>clrm-package.rb</code> script.
This naive script does the following: 
</p>

<ol>
    <li>an empty package is made
    <li>the core module scripts are concatenated and added to the package under
        the <code>module</code> key
    <li>for each HTML resource, all linked CSS and JavaScript files in 
        <code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> tags are
        added to the list of resources and are replaced with their references
        (see the <a href="#implement:referencing-resources">Referencing Module 
        Resources</a>section). E.g., this:
<pre class="prettyprint">
&lt;html&gt;
  &lt;head&gt;
    &lt;script src="myscript.js"&gt;&lt;/script&gt;
    &lt;link href="mystyle.css" rel="stylesheet" type="text/css"/&gt;
  &lt;/head&gt;
  &lt;body&gt;
  ...
  &lt;/body&gt;
&lt;/html&gt;
</pre> 
becomes:
<pre class="prettyprint">
&lt;html&gt;
  &lt;head&gt;
::CLRMJS:myscript.js
::CLRMCSS:mystyle.css
  &lt;/head&gt;
  &lt;body&gt;
  ...
  &lt;/body&gt;
&lt;/html&gt;
</pre>    
    <li>for each resource, it makes an entry in the corresponding map in the 
        package; each resources base filename is used as the key

</ol>



</body>
</html>