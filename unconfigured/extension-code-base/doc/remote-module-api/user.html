<html>
<head>
    <script src="js/external/jquery.min.js"></script>
    <script src="js/content-page.js"></script>
</head>
<body>
<div class="toc">
    <h2>Contents</h2>
    <ul>
        <!-- <li><a href="#user">User API (top)</a> -->
        <li><a href="#user:history">Accessing User History</a>
        <ul>
                <li><a href="#user:readlog">Reading From Logs</a>
                <li><a href="#user:writelog">Writing To Logs</a>
                <li><a href="#user:updatelog">Updating Logs</a>
                <li><a href="#user:clearlog">Clearing Logs</a>
        </ul>
        <li><a href="#user:realtime">Accessing Real-Time User Activity</a>
        <li><a href="#user:save">Saving Data</a>
    </ul>
</div>



<h1>User API</h1>

<a name="history"></a>
<h2>Accessing User History</h2>

<p>
The user's browsing history, as logged by CrowdLogger, can be accessed via the
<code>CROWDLOGGER.io.log</code> interface. Currently, this uses IndexedDB as a 
backend, which is important if you want to store your own data 
(<a href="#user:save">see below</a>). CrowdLogger has two default logs:
the <i>activity log</i> and the <i>error log</i>. The former contains all 
browsing and search activity, including clicks, queries, tab events, and
page loads. Each event is stored as its own entry and is encapsulated within
an object. Here's a description of the object fields for each kind of event.
All events have at minimum two fields: <code>id</code> (a unique id used by
the database) and <code>e</code> (for "event", see table below). Currently they
also all have a <code>t</code> (timestamp) field, as well, but we may introduce
some new events that don't.
</p>

<table>
    <tr>
        <th>Event</th> <th>Fields</th> 
    </tr><tr>
        <td>search</td> 
        <td>
            <ul>
                <li><code>t</code>: The timestamp.
                <li><code>q</code>: The parsed query.
                <li><code>se</code>: The search engine.
                <li><code>url</code>: The URL of the results page.
            </ul>
E.g.:
<pre class='prettyprint'>{id: 1,
 e: 'search', 
 t: 1359928100, 
 q: 'upcoming movies', 
 se: 'google', 
 url: 'https://www.google.com/search?q=upcoming+movies'}
</pre>
        </td>
    </tr><tr>
        <td>click</td>
        <td>
            <ul>
                <li><code>t</code>: The timestamp.
                <li><code>turl</code>: The clicked URL.
                <li><code>surl</code>: The URL of the page on which the click occured.
                <li><code>sr</code>: <code>true</code> if the source url (<code>surl</code>) is a Search Engine Results Page and the target URL is a <i>search result</i> on that page.
                <li><code>q</code>: If <code>sr==true</code>, then this contains the associated query.
            </ul>
E.g.:
<pre class='prettyprint'>{id: 1,
 e: 'click', 
 t: 1359928100, 
 turl: 'http://en.wikipedia.org/wiki/Panda', 
 surl: 'https://www.google.com/search?q=panda',
 sr: true,
 q: panda}
</pre>
        </td>
    </tr><tr>
        <td>tabadd</td>
        <td>
            <ul>
                <li><code>t</code>: The timestamp.
                <li><code>ttid</code>: The target tab id (the one being added).
                <li><code>turl</code>: The URL loaded in the new tab.
                <li><code>stid</code>: The source tab id (the one from which the new one was added).
                <li><code>surl</code>: The URL loaded in the source tab.
            </ul>
E.g.:
<pre class='prettyprint'>{id: 1,
 e: 'tabadd', 
 t: 1359928100, 
 ttid: 2k3,
 turl: 'http://www.cnn.com', 
 stid: 4wi5a,
 surl: 'http://en.wikipedia.org/wiki/Panda'}
</pre>
        </td>
    </tr><tr>
        <td>tabremove</td>
        <td>
            <ul>
                <li><code>t</code>: The timestamp.
                <li><code>tid</code>: The id of the removed tab.
            </ul>
E.g.:
<pre class='prettyprint'>{id: 1,
 e: 'tabremove', 
 t: 1359928100, 
 tid: 2k3}
</pre>
        </td>
    </tr><tr>
        <td>pageload</td>
        <td>
            <ul>
                <li><code>t</code>: The timestamp.
                <li><code>tid</code>: The id of the tab in which the page was loaded.
                <li><code>url</code>: The loaded URL.
            </ul>
E.g.:
<pre class='prettyprint'>{id: 1,
 e: 'pageload', 
 t: 1359928100, 
 tid: 2k3,
 url: 'http://www.cnn.com'}
</pre>
        </td>
    </tr><tr>
        <td>pagefocus</td>
        <td>
            <ul>
                <li><code>t</code>: The timestamp.
                <li><code>tid</code>: The id of the tab in which the page was focused.
                <li><code>url</code>: The URL of the focused page.
            </ul>
E.g.:
<pre class='prettyprint'>{id: 1,
 e: 'pagefocus', 
 t: 1359928100, 
 tid: 2k3,
 url: 'http://www.cnn.com'}
</pre>
        </td>
    </tr>
</table>

<p>
The <code>CROWDLOGGER.io.log</code> interface allows four operations
</p>

<ul>
    <li><a href="#user:readlog">read</a>
    <li><a href="#user:writelog">write (add, replace entries)</a>
    <li><a href="#user:updatelog">update (modify or delete entries)</a>
    <li><a href="#user:clearlog">clear</a>
</ul>

<!-- Read log entries. -->
<a name="readlog"></a>
<h3>Reading log entries</h3>
<p>
To read the activity or error logs, you will use the <code>CROWDLOGGER.io.log.read_activity_log</code> and <code>CROWDLOGGER.io.log.read_error_log</code> functions. The take the same parameter: a map of options. I.e.:
</p>

<table>
    <tr>
        <th>Option key</th> <th>Type</th> <th>Description</th>
    </tr><tr>
        <td colspan="3"><i>Required</i></td>
    </tr><tr>
        <td><code>on_chunk</code></td>
        <td>function</td>
        <td>Invoked per chunk (see <code>chunk_size</code> below). Chunks are 
            processed asynchronously. It should expect two parameters: an
            array of entries (objects) and a 'next' function, which, when 
            invoked, will read in the next chunk asynchronously.
        </td>
    </tr>

    <tr>
        <td colspan="3"><i>Optional</i></td>
    </tr><tr>
        <td><code>on_success</code></td>
        <td>function</td>
        <td>Invoked when everything has been read and processed by 
            <code>on_chunk</code>.</td>
    </tr><tr>
        <td><code>on_error</code></td>
        <td>function</td>
        <td>Invoked if there's an error.</td>
    </tr><tr>
        <td><code>chunk_size</code></td>
        <td>integer</td>
        <td>The size of the chunks to process. E.g.,
            <coode>chunk_size = 50</code> will cause 50 entries to
            be read, stored in an array, and then
            passed to the on_chunk function. If &lt;=0,
            all entries will be read in before
            calling <code>on_chunk</code>. This is approximate
            because ranges are used and therefore
            deleted items within that range will not
            be read (their id's are not reused).
            Default: 0.
        </td>
    </tr><tr>
        <td><code>reverse</code></td>
        <td>boolean</td>
        <td>If true, the data will be read in reverse
            order of id. Default is 'false'.
        </td>
    </tr><tr>
        <td><code>lower_bound</code></td>
        <td>integer</td>
        <td>The smallest id to retrieve; default: 0</td>
    </tr><tr>
        <td><code>upper_bound</code></td>
        <td>integer</td>
        <td>The largest id to retrieve; default: -1
            (all ids >= lower_bound are retrieved).
        </td>
    </tr>
</table>

<p>
Lets go over a few common patterns. If you want to <b>read the entire activity log 
at once</b>, you can do something like this:
</p>

<pre class="prettyprint">
// Prints each of the given entries.
function print_entries( entries, next /* ignored */ ){
    var i;
    for( i = 0; i &lt; entries.length; i++ ){
        CROWDLOGGER.debug.log( JSON.stringify(entries[i]) );
    }
}

// Read the log and print the entries.
CROWDLOGGER.io.log.read_activity_log({
    on_chunk: print_entries
});
</pre>

<p>
If you are sure you're going to have to do something with all of logged
data AND you think that the log is small enough that it shouldn't be an issue,
then this method is okay. However, most of the time, you probably don't need to
read all the logged data at once. For instance, suppose you are <b>populating a
search history web page</b>. If the user hasn't scrolled to the bottom of the page
yet, there's no reason to load any additional content. So, we want to chunk
the data and traverse it in reverse order (most recent log entries first):
</p>

<pre class="prettyprint">
var body = jQuery('&lt;div&gt;');

// Appends a set of entries to an html page.
function append_entries_to_page( entries, next ){
    var i, entry_elm;

    // Append the entries as spans of text.
    for( i = 0; i &lt; entries.length; i++ ){
        entry_elm = jQuery('&lt;span&gt;').text(entries[i].e +'@'+ entries[i].t);
        body.append(entry_elm);
    }

    // When the last element comes into view, read the next chunk. The 'next' function knows 
    // to call this function again, so we don't have to pass any additional information.
    function on_focus(e){
        next();
        jQuery(this).unbind('focus', on_focus);
    }
    if( entry_elm ){ entry_elm.focus(on_focus); }
}

// Read the log, reading entries in 50-entry chunks, and add them to the
// body element. We're reading in reverse, so we set reverse: true.
CROWDLOGGER.io.log.read_activity_log({
    on_chunk: append_entries_to_page,
    chunk_size: 50,
    reverse: true
});
</pre>

<p>
The other options are useful for various situations. The <code>on_success</code>
is convenient if you need to do something once all the data has been read
and processed. Note that this call will never be made if the 'next' function
isn't invoked. The <code>upper_bound</code> and <code>lower_bound</code> 
options are handy if you know the minimum or maximum ids of the entries you 
would like to retrieve&emdash;after all, why read in everything if you don't
need to?
</p>




<!-- Write log entries. -->
<a name="writelog"></a>
<h3>Write log entries</h3>

<p>
Use the <code>CROWDLOGGER.io.log.write_to_activity_log</code> and
<code>CROWDLOGGER.io.log.write_to_error_log</code> to write data or update
a specific entry for which you have the id and other attributes (i.e., you
don't have to read it first). Extensions probably won't be performing these
actions, but this is good to know, anyway. The write functions take a
single parameter, as before: a map of options. 
</p>

<table>
    <tr>
        <th>Option key</th> <th>Type</th> <th>Description</th>
    </tr><tr>
        <td colspan="3"><i>Required</i></td>
    </tr><tr>
        <td><code>data</code></td>
        <td>array of objects</td>
        <td>An array of entries to be added. If an entry contains an id, and an entry with that id exists, then it will be overwritten by the new entry.
        </td>
    </tr>

    <tr>
        <td colspan="3"><i>Optional</i></td>
    </tr><tr>
        <td><code>on_success</code></td>
        <td>function</td>
        <td>Invoked when everything has been successfully written.
    </tr><tr>
        <td><code>on_error</code></td>
        <td>function</td>
        <td>Invoked if there's an error.</td>
    </tr>
</table>

<p>
One common pattern is to add a new entry. In this case, make the object to store
and leave off the <code>id</code> field&mdash;the database will take care of
setting this.
</p>

<pre class="prettyprint">
// A new 'search' event.
var new_search = {
    timestamp: new Date().getTime(),
    e: 'search',
    q: 'upcoming movies',
    se: 'google',
    url: 'https://www.google.com/search?q=upcoming+movies'
};

// Add the entry to the activity log. Note that the data field consists of
// a single-element array because we are only adding one entry.
CROWDLOGGER.io.log.write_to_activity_log({data: [new_search]});
</pre>

<p>
Another common use case is that you would like to modify an entry that you read 
from the log earlier (maybe clean up the URL or something). As long as you know 
the <code>id</code>, you can do the following:
</p>

<pre class="prettyprint">
// Modifying a search event we read earlier. Has id = 558. We are extracting
// the search engine using a new algorithm.
my_search.se = extract_se(my_search.url);

// When we write this to the log, it will replace the previous version.
CROWDLOGGER.io.log.write_to_activity_log({data: [my_search]});
</pre>

<p>
Finally, if you have multiple entries you'd like to add, that's easy:
</p>

<pre class="prettyprint lang-js">
// Assume we have five entries named e1, e2, e3, e4, and e5.
CROWDLOGGER.io.log.write_to_activity_log({data: [e1, e2, e3, e4, e5]});
</pre>



<!-- Update log entries. -->
<a name="updatelog"></a>
<h3>Update log entries</h3>

<p>
The <code>CROWDLOGGER.io.log.update_activity_log</code> and
<code>CROWDLOGGER.io.log.update_error_log</code> functions iterate over every
entry in a log, passing each to a function you provide (see <code>foreach</code>
in the table below), where you can choose to update the entry, delete it, stop
iterating, or ignore the entry and move on. As before, the functions take a
single parameter, which is a map of options, as described below:
</p>

<table>
    <tr>
        <th>Option key</th> <th>Type</th> <th>Description</th>
    </tr><tr>
        <td colspan="3"><i>Required</i></td>
    </tr><tr>
        <td><code>foreach</code></td>
        <td>function</td>
        <td>
            A function to run on each entry. It
            should take a log entry as its
            only parameter and optionally return
            an object with three optional fields:
            <ul>
                <li><code>entry</code> (new data, ids must match),
                <li><code>stop</code> (<code>true</code> or <code>false</code>)
                <li><code>delete</code> (<code>true</code> or <code>false</code>)
            </ul>
            This function <i>must</i> be synchronous.
            As soon as it returns, there's no more updating.
        </td>
    </tr>

    <tr>
        <td colspan="3"><i>Optional</i></td>
    </tr><tr>
        <td><code>on_success</code></td>
        <td>function</td>
        <td>Invoked when everything has been successfully written.
    </tr><tr>
        <td><code>on_error</code></td>
        <td>function</td>
        <td>Invoked if there's an error.</td>
    </tr>
</table>

<p>
The update operation is helpful when you want to update all (or most) entries in a log. For example, say you wanted to store the top 10 results associated with searches, and lets suppose you have a magical function <code>extract_top_ten_results</code> that can reproduce the results page seen by a user and extract those links. The code to update all of the search entries might look like this:
</p>

<pre class="prettyprint">
// This is the update function; it only effects search entries.
function update_search_entry(entry) {
    if( entry.e === 'search' ){
        entry.top_ten_results = extract_top_ten_results(entry.url);
        return {entry: entry};
    }
    return {};
}

// Update the log.
CROWDLOGGER.io.log.update_activity_log({foreach: update_search_entry});
</pre>

<p>
If an entry is deleted, the numbering of the database will remain unchanged (the
id of the deleted entry will never be used by another entry, unless you specify
it when writing a new entry).
</p>

<!-- Clear log entries. -->
<a name="clearlog"></a>
<h3>Clear log entries</h3>

<p>
Clearing logs (or truncating them) can be done by using
<code>CROWDLOGGER.io.log.clear_activity_log</code> and
<code>CROWDLOGGER.io.log.clear_error_log</code>. These will remove all entries
from the log. Note that the numbering of the log entry ids does not reset after
this operation. The functions take one parameter, a map of options (none required):
</p>

<table>
    <tr>
        <th>Option key</th> <th>Type</th> <th>Description</th>
    </tr><tr>
        <td colspan="3"><i>Optional</i></td>
    </tr><tr>
        <td><code>on_success</code></td>
        <td>function</td>
        <td>Invoked when everything has been successfully written.
    </tr><tr>
        <td><code>on_error</code></td>
        <td>function</td>
        <td>Invoked if there's an error.</td>
    </tr>
</table>


<a name="realtime"></a>
<h2>Accessing Real-time User Activity</h2>

TODO


<a name="save"></a>
<h2>Saving Data</h2>

<p>
For each of the operations listed in the <a href="user:history">Accessing User
History</a> section, there is a parallel for custom CrowdLogger extension logs.
The differences are that you will always need to supply a database name
(whatever you want, but should be unique) and version (an integer), and there
are a few additional options available. Internally, each extension log is put in
its own database. You can specify how to initialize it or update it between
database versions, or you can rely on the default extension store creator, which
gives you a single store that uses the <code>id</code> as the storage key (auto-
incrementing). 
</p>

<p>
For the read, write, update, and clear operations, use:
</p>

<ul>
    <li><code>CROWDLOGGER.io.log.read_extension_log</code>
    <li><code>CROWDLOGGER.io.log.write_to_extension_log</code>
    <li><code>CROWDLOGGER.io.log.update_extension_log</code>
    <li><code>CROWDLOGGER.io.log.clear_extension_log</code>
</ul>

<p>
These take all the same options as their activity and error log equivalents, but
with the following set of additional required and optional fields:
</p>

<table>
    <tr>
        <th>Option key</th> <th>Type</th> <th>Description</th>
    </tr><tr>
        <td colspan="3"><i>Required</i></td>
    </tr><tr>
        <td><code>db_name</code></td>
        <td>string</td>
        <td>
            The name of the database. Should be unique, which means you should
            probably start it with the name of your extension and then something
            descriptive, e.g., <code>sta_data</code> for the Search Task 
            Assistant extension.
        </td>
    </tr><tr>
        <td><code>db_version</code></td>
        <td>integer</td>
        <td>
            The version of the database. If the current database version is less
            than this value, the <code>on_upgrade</code> function will be
            invoked (if you don't specify that function, then a default will
            be used).
        </td>
    </tr>

    <tr>
        <td colspan="3"><i>Optional</i></td>
    </tr><tr>
        <td><code>on_upgrade</code></td>
        <td>function</td>
        <td>
            Invoked if the database does not exist or if the version number is
            old. This function should take an <code>IndexedDB</code> database
            instance and  should not rely on any asynchronous calls. It should
            return true if things went as planned. It should
            be used to create stores and indexes for the database. This is
            invoked before any read, write, update, or clear operations are
            executed.
    </tr><tr>
        <td><code>store_name</code></td>
        <td>string</td>
        <td>The store in the database on which to perform the given operation.
            If you've specified an <code>on_upgrade</code> function, you should
            probably set this option.
        </td>
    </tr>
</table>

<p>
An example of when you'd want to specify your own <code>on_upgrade</code>
function is if you need multiple stores. E.g., the Search Task Assistant stores
searches and tasks, and each should be stored in a separate store (and no sense
wasting a separate database). Another example is if you want an index to access
certain types of entries faster. Let's look at how I would use the various
operations for the Search Task Assistant (currently, this is a hypothetical and
this code hasn't been tested).
</p>

<pre class="prettyprint">
var DB_VERSION = 1,
    DB_NAME = 'sta_data',
    TASK_STORE = 'tasks',
    SEARCH_STORE = 'searches';

// Initializes the database.
function upgrade_db(db) {
    // Create the log to store searches.
    db.createObjectStore( 
        SEARCH_STORE, {keyPath: 'id', autoIncrement: true});

    // Create the log to store tasks.
    db.createObjectStore(
        TASK_STORE, {keyPath: 'id', autoIncrement: true});

    return true;
}

// Prints the given entry.
function print_entries( entries, next ){
    var i;
    for( i = 0; i &lt; entries.length; i++ ){
        CROWDLOGGER.debug.log( JSON.stringify(entries[i]) );
    }

    // Read the next batch in a little bit.
    setTimeout( next, 10 );
}

// Write some entries to the tasks log.
CROWDLOGGER.io.log.write_to_extension_log({
    db_name: DB_NAME,
    db_version: DB_VERSION,
    on_upgrade: upgrade_db,
    store_name: TASK_STORE,
    data: [
        {name: "task 1", time: 1359928100},
        {name: "task 2", time: 1359928101},
        {name: "task 3", time: 1359928102},
        {name: "task 4", time: 1359928103},
        {name: "task 5", time: 1359928104}
    ]
});

// Print them all out.
CROWDLOGGER.io.log.read_extension_log({
    db_name: DB_NAME,
    db_version: DB_VERSION,
    on_upgrade: upgrade_db,
    store_name: TASK_STORE,
    on_chunk: print_entries,
    chunk_size: 50,
    reverse: true
});
</pre>

</body>
</html>